/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: mmtp.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum MsgType {
    UNSPECIFIED_MESSAGE = 0,
    PROTOCOL_MESSAGE = 1,
    RESPONSE_MESSAGE = 2
}
export enum ProtocolMessageType {
    UNSPECIFIED = 0,
    SUBSCRIBE_MESSAGE = 1,
    UNSUBSCRIBE_MESSAGE = 2,
    SEND_MESSAGE = 3,
    RECEIVE_MESSAGE = 4,
    FETCH_MESSAGE = 5,
    DISCONNECT_MESSAGE = 6,
    CONNECT_MESSAGE = 7,
    NOTIFY_MESSAGE = 8
}
export enum ResponseEnum {
    UNSPECIFIED_RESPONSE = 0,
    GOOD = 1,
    ERROR = 2
}
export class ApplicationMessage extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        header?: ApplicationMessageHeader;
        body?: Uint8Array;
        signature?: Uint8Array;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("header" in data && data.header != undefined) {
                this.header = data.header;
            }
            if ("body" in data && data.body != undefined) {
                this.body = data.body;
            }
            if ("signature" in data && data.signature != undefined) {
                this.signature = data.signature;
            }
        }
    }
    get header() {
        return pb_1.Message.getWrapperField(this, ApplicationMessageHeader, 1) as ApplicationMessageHeader;
    }
    set header(value: ApplicationMessageHeader) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_header() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get body() {
        return pb_1.Message.getFieldWithDefault(this, 2, new Uint8Array(0)) as Uint8Array;
    }
    set body(value: Uint8Array) {
        pb_1.Message.setField(this, 2, value);
    }
    get signature() {
        return pb_1.Message.getFieldWithDefault(this, 3, new Uint8Array(0)) as Uint8Array;
    }
    set signature(value: Uint8Array) {
        pb_1.Message.setField(this, 3, value);
    }
    static fromObject(data: {
        header?: ReturnType<typeof ApplicationMessageHeader.prototype.toObject>;
        body?: Uint8Array;
        signature?: Uint8Array;
    }): ApplicationMessage {
        const message = new ApplicationMessage({});
        if (data.header != null) {
            message.header = ApplicationMessageHeader.fromObject(data.header);
        }
        if (data.body != null) {
            message.body = data.body;
        }
        if (data.signature != null) {
            message.signature = data.signature;
        }
        return message;
    }
    toObject() {
        const data: {
            header?: ReturnType<typeof ApplicationMessageHeader.prototype.toObject>;
            body?: Uint8Array;
            signature?: Uint8Array;
        } = {};
        if (this.header != null) {
            data.header = this.header.toObject();
        }
        if (this.body != null) {
            data.body = this.body;
        }
        if (this.signature != null) {
            data.signature = this.signature;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_header)
            writer.writeMessage(1, this.header, () => this.header.serialize(writer));
        if (this.body.length)
            writer.writeBytes(2, this.body);
        if (this.signature.length)
            writer.writeBytes(3, this.signature);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ApplicationMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ApplicationMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.header, () => message.header = ApplicationMessageHeader.deserialize(reader));
                    break;
                case 2:
                    message.body = reader.readBytes();
                    break;
                case 3:
                    message.signature = reader.readBytes();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ApplicationMessage {
        return ApplicationMessage.deserialize(bytes);
    }
}
export class ApplicationMessageHeader extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2], [5]];
    constructor(data?: any[] | ({
        expires?: number;
        sender?: string;
        bodySizeNumBytes?: number;
    } & (({
        subject?: string;
        recipients?: never;
    } | {
        subject?: never;
        recipients?: Recipients;
    }) | ({
        qosProfile?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("subject" in data && data.subject != undefined) {
                this.subject = data.subject;
            }
            if ("recipients" in data && data.recipients != undefined) {
                this.recipients = data.recipients;
            }
            if ("expires" in data && data.expires != undefined) {
                this.expires = data.expires;
            }
            if ("sender" in data && data.sender != undefined) {
                this.sender = data.sender;
            }
            if ("qosProfile" in data && data.qosProfile != undefined) {
                this.qosProfile = data.qosProfile;
            }
            if ("bodySizeNumBytes" in data && data.bodySizeNumBytes != undefined) {
                this.bodySizeNumBytes = data.bodySizeNumBytes;
            }
        }
    }
    get subject() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set subject(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_subject() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get recipients() {
        return pb_1.Message.getWrapperField(this, Recipients, 2) as Recipients;
    }
    set recipients(value: Recipients) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_recipients() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get expires() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set expires(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get sender() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set sender(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get qosProfile() {
        return pb_1.Message.getFieldWithDefault(this, 5, "") as string;
    }
    set qosProfile(value: string) {
        pb_1.Message.setOneofField(this, 5, this.#one_of_decls[1], value);
    }
    get has_qosProfile() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get bodySizeNumBytes() {
        return pb_1.Message.getFieldWithDefault(this, 6, 0) as number;
    }
    set bodySizeNumBytes(value: number) {
        pb_1.Message.setField(this, 6, value);
    }
    get SubjectOrRecipient() {
        const cases: {
            [index: number]: "none" | "subject" | "recipients";
        } = {
            0: "none",
            1: "subject",
            2: "recipients"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    get _qosProfile() {
        const cases: {
            [index: number]: "none" | "qosProfile";
        } = {
            0: "none",
            5: "qosProfile"
        };
        return cases[pb_1.Message.computeOneofCase(this, [5])];
    }
    static fromObject(data: {
        subject?: string;
        recipients?: ReturnType<typeof Recipients.prototype.toObject>;
        expires?: number;
        sender?: string;
        qosProfile?: string;
        bodySizeNumBytes?: number;
    }): ApplicationMessageHeader {
        const message = new ApplicationMessageHeader({});
        if (data.subject != null) {
            message.subject = data.subject;
        }
        if (data.recipients != null) {
            message.recipients = Recipients.fromObject(data.recipients);
        }
        if (data.expires != null) {
            message.expires = data.expires;
        }
        if (data.sender != null) {
            message.sender = data.sender;
        }
        if (data.qosProfile != null) {
            message.qosProfile = data.qosProfile;
        }
        if (data.bodySizeNumBytes != null) {
            message.bodySizeNumBytes = data.bodySizeNumBytes;
        }
        return message;
    }
    toObject() {
        const data: {
            subject?: string;
            recipients?: ReturnType<typeof Recipients.prototype.toObject>;
            expires?: number;
            sender?: string;
            qosProfile?: string;
            bodySizeNumBytes?: number;
        } = {};
        if (this.subject != null) {
            data.subject = this.subject;
        }
        if (this.recipients != null) {
            data.recipients = this.recipients.toObject();
        }
        if (this.expires != null) {
            data.expires = this.expires;
        }
        if (this.sender != null) {
            data.sender = this.sender;
        }
        if (this.qosProfile != null) {
            data.qosProfile = this.qosProfile;
        }
        if (this.bodySizeNumBytes != null) {
            data.bodySizeNumBytes = this.bodySizeNumBytes;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_subject)
            writer.writeString(1, this.subject);
        if (this.has_recipients)
            writer.writeMessage(2, this.recipients, () => this.recipients.serialize(writer));
        if (this.expires != 0)
            writer.writeInt64(3, this.expires);
        if (this.sender.length)
            writer.writeString(4, this.sender);
        if (this.has_qosProfile)
            writer.writeString(5, this.qosProfile);
        if (this.bodySizeNumBytes != 0)
            writer.writeUint32(6, this.bodySizeNumBytes);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ApplicationMessageHeader {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ApplicationMessageHeader();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.subject = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.recipients, () => message.recipients = Recipients.deserialize(reader));
                    break;
                case 3:
                    message.expires = reader.readInt64();
                    break;
                case 4:
                    message.sender = reader.readString();
                    break;
                case 5:
                    message.qosProfile = reader.readString();
                    break;
                case 6:
                    message.bodySizeNumBytes = reader.readUint32();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ApplicationMessageHeader {
        return ApplicationMessageHeader.deserialize(bytes);
    }
}
export class Recipients extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        recipients?: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("recipients" in data && data.recipients != undefined) {
                this.recipients = data.recipients;
            }
        }
    }
    get recipients() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set recipients(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        recipients?: string[];
    }): Recipients {
        const message = new Recipients({});
        if (data.recipients != null) {
            message.recipients = data.recipients;
        }
        return message;
    }
    toObject() {
        const data: {
            recipients?: string[];
        } = {};
        if (this.recipients != null) {
            data.recipients = this.recipients;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.recipients.length)
            writer.writeRepeatedString(1, this.recipients);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Recipients {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Recipients();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Recipients {
        return Recipients.deserialize(bytes);
    }
}
export class MmtpMessage extends pb_1.Message {
    #one_of_decls: number[][] = [[3, 4]];
    constructor(data?: any[] | ({
        msgType?: MsgType;
        uuid?: string;
    } & (({
        protocolMessage?: ProtocolMessage;
        responseMessage?: never;
    } | {
        protocolMessage?: never;
        responseMessage?: ResponseMessage;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("msgType" in data && data.msgType != undefined) {
                this.msgType = data.msgType;
            }
            if ("uuid" in data && data.uuid != undefined) {
                this.uuid = data.uuid;
            }
            if ("protocolMessage" in data && data.protocolMessage != undefined) {
                this.protocolMessage = data.protocolMessage;
            }
            if ("responseMessage" in data && data.responseMessage != undefined) {
                this.responseMessage = data.responseMessage;
            }
        }
    }
    get msgType() {
        return pb_1.Message.getFieldWithDefault(this, 1, MsgType.UNSPECIFIED_MESSAGE) as MsgType;
    }
    set msgType(value: MsgType) {
        pb_1.Message.setField(this, 1, value);
    }
    get uuid() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set uuid(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get protocolMessage() {
        return pb_1.Message.getWrapperField(this, ProtocolMessage, 3) as ProtocolMessage;
    }
    set protocolMessage(value: ProtocolMessage) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_protocolMessage() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get responseMessage() {
        return pb_1.Message.getWrapperField(this, ResponseMessage, 4) as ResponseMessage;
    }
    set responseMessage(value: ResponseMessage) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_responseMessage() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get body() {
        const cases: {
            [index: number]: "none" | "protocolMessage" | "responseMessage";
        } = {
            0: "none",
            3: "protocolMessage",
            4: "responseMessage"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3, 4])];
    }
    static fromObject(data: {
        msgType?: MsgType;
        uuid?: string;
        protocolMessage?: ReturnType<typeof ProtocolMessage.prototype.toObject>;
        responseMessage?: ReturnType<typeof ResponseMessage.prototype.toObject>;
    }): MmtpMessage {
        const message = new MmtpMessage({});
        if (data.msgType != null) {
            message.msgType = data.msgType;
        }
        if (data.uuid != null) {
            message.uuid = data.uuid;
        }
        if (data.protocolMessage != null) {
            message.protocolMessage = ProtocolMessage.fromObject(data.protocolMessage);
        }
        if (data.responseMessage != null) {
            message.responseMessage = ResponseMessage.fromObject(data.responseMessage);
        }
        return message;
    }
    toObject() {
        const data: {
            msgType?: MsgType;
            uuid?: string;
            protocolMessage?: ReturnType<typeof ProtocolMessage.prototype.toObject>;
            responseMessage?: ReturnType<typeof ResponseMessage.prototype.toObject>;
        } = {};
        if (this.msgType != null) {
            data.msgType = this.msgType;
        }
        if (this.uuid != null) {
            data.uuid = this.uuid;
        }
        if (this.protocolMessage != null) {
            data.protocolMessage = this.protocolMessage.toObject();
        }
        if (this.responseMessage != null) {
            data.responseMessage = this.responseMessage.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.msgType != MsgType.UNSPECIFIED_MESSAGE)
            writer.writeEnum(1, this.msgType);
        if (this.uuid.length)
            writer.writeString(2, this.uuid);
        if (this.has_protocolMessage)
            writer.writeMessage(3, this.protocolMessage, () => this.protocolMessage.serialize(writer));
        if (this.has_responseMessage)
            writer.writeMessage(4, this.responseMessage, () => this.responseMessage.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MmtpMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MmtpMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.msgType = reader.readEnum();
                    break;
                case 2:
                    message.uuid = reader.readString();
                    break;
                case 3:
                    reader.readMessage(message.protocolMessage, () => message.protocolMessage = ProtocolMessage.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.responseMessage, () => message.responseMessage = ResponseMessage.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MmtpMessage {
        return MmtpMessage.deserialize(bytes);
    }
}
export class ProtocolMessage extends pb_1.Message {
    #one_of_decls: number[][] = [[2, 3, 4, 5, 6, 7, 8, 9]];
    constructor(data?: any[] | ({
        protocolMsgType?: ProtocolMessageType;
    } & (({
        subscribeMessage?: Subscribe;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: Unsubscribe;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: Send;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: Receive;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: Fetch;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: Disconnect;
        connectMessage?: never;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: Connect;
        notifyMessage?: never;
    } | {
        subscribeMessage?: never;
        unsubscribeMessage?: never;
        sendMessage?: never;
        receiveMessage?: never;
        fetchMessage?: never;
        disconnectMessage?: never;
        connectMessage?: never;
        notifyMessage?: Notify;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("protocolMsgType" in data && data.protocolMsgType != undefined) {
                this.protocolMsgType = data.protocolMsgType;
            }
            if ("subscribeMessage" in data && data.subscribeMessage != undefined) {
                this.subscribeMessage = data.subscribeMessage;
            }
            if ("unsubscribeMessage" in data && data.unsubscribeMessage != undefined) {
                this.unsubscribeMessage = data.unsubscribeMessage;
            }
            if ("sendMessage" in data && data.sendMessage != undefined) {
                this.sendMessage = data.sendMessage;
            }
            if ("receiveMessage" in data && data.receiveMessage != undefined) {
                this.receiveMessage = data.receiveMessage;
            }
            if ("fetchMessage" in data && data.fetchMessage != undefined) {
                this.fetchMessage = data.fetchMessage;
            }
            if ("disconnectMessage" in data && data.disconnectMessage != undefined) {
                this.disconnectMessage = data.disconnectMessage;
            }
            if ("connectMessage" in data && data.connectMessage != undefined) {
                this.connectMessage = data.connectMessage;
            }
            if ("notifyMessage" in data && data.notifyMessage != undefined) {
                this.notifyMessage = data.notifyMessage;
            }
        }
    }
    get protocolMsgType() {
        return pb_1.Message.getFieldWithDefault(this, 1, ProtocolMessageType.UNSPECIFIED) as ProtocolMessageType;
    }
    set protocolMsgType(value: ProtocolMessageType) {
        pb_1.Message.setField(this, 1, value);
    }
    get subscribeMessage() {
        return pb_1.Message.getWrapperField(this, Subscribe, 2) as Subscribe;
    }
    set subscribeMessage(value: Subscribe) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_subscribeMessage() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get unsubscribeMessage() {
        return pb_1.Message.getWrapperField(this, Unsubscribe, 3) as Unsubscribe;
    }
    set unsubscribeMessage(value: Unsubscribe) {
        pb_1.Message.setOneofWrapperField(this, 3, this.#one_of_decls[0], value);
    }
    get has_unsubscribeMessage() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get sendMessage() {
        return pb_1.Message.getWrapperField(this, Send, 4) as Send;
    }
    set sendMessage(value: Send) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_sendMessage() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get receiveMessage() {
        return pb_1.Message.getWrapperField(this, Receive, 5) as Receive;
    }
    set receiveMessage(value: Receive) {
        pb_1.Message.setOneofWrapperField(this, 5, this.#one_of_decls[0], value);
    }
    get has_receiveMessage() {
        return pb_1.Message.getField(this, 5) != null;
    }
    get fetchMessage() {
        return pb_1.Message.getWrapperField(this, Fetch, 6) as Fetch;
    }
    set fetchMessage(value: Fetch) {
        pb_1.Message.setOneofWrapperField(this, 6, this.#one_of_decls[0], value);
    }
    get has_fetchMessage() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get disconnectMessage() {
        return pb_1.Message.getWrapperField(this, Disconnect, 7) as Disconnect;
    }
    set disconnectMessage(value: Disconnect) {
        pb_1.Message.setOneofWrapperField(this, 7, this.#one_of_decls[0], value);
    }
    get has_disconnectMessage() {
        return pb_1.Message.getField(this, 7) != null;
    }
    get connectMessage() {
        return pb_1.Message.getWrapperField(this, Connect, 8) as Connect;
    }
    set connectMessage(value: Connect) {
        pb_1.Message.setOneofWrapperField(this, 8, this.#one_of_decls[0], value);
    }
    get has_connectMessage() {
        return pb_1.Message.getField(this, 8) != null;
    }
    get notifyMessage() {
        return pb_1.Message.getWrapperField(this, Notify, 9) as Notify;
    }
    set notifyMessage(value: Notify) {
        pb_1.Message.setOneofWrapperField(this, 9, this.#one_of_decls[0], value);
    }
    get has_notifyMessage() {
        return pb_1.Message.getField(this, 9) != null;
    }
    get body() {
        const cases: {
            [index: number]: "none" | "subscribeMessage" | "unsubscribeMessage" | "sendMessage" | "receiveMessage" | "fetchMessage" | "disconnectMessage" | "connectMessage" | "notifyMessage";
        } = {
            0: "none",
            2: "subscribeMessage",
            3: "unsubscribeMessage",
            4: "sendMessage",
            5: "receiveMessage",
            6: "fetchMessage",
            7: "disconnectMessage",
            8: "connectMessage",
            9: "notifyMessage"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2, 3, 4, 5, 6, 7, 8, 9])];
    }
    static fromObject(data: {
        protocolMsgType?: ProtocolMessageType;
        subscribeMessage?: ReturnType<typeof Subscribe.prototype.toObject>;
        unsubscribeMessage?: ReturnType<typeof Unsubscribe.prototype.toObject>;
        sendMessage?: ReturnType<typeof Send.prototype.toObject>;
        receiveMessage?: ReturnType<typeof Receive.prototype.toObject>;
        fetchMessage?: ReturnType<typeof Fetch.prototype.toObject>;
        disconnectMessage?: ReturnType<typeof Disconnect.prototype.toObject>;
        connectMessage?: ReturnType<typeof Connect.prototype.toObject>;
        notifyMessage?: ReturnType<typeof Notify.prototype.toObject>;
    }): ProtocolMessage {
        const message = new ProtocolMessage({});
        if (data.protocolMsgType != null) {
            message.protocolMsgType = data.protocolMsgType;
        }
        if (data.subscribeMessage != null) {
            message.subscribeMessage = Subscribe.fromObject(data.subscribeMessage);
        }
        if (data.unsubscribeMessage != null) {
            message.unsubscribeMessage = Unsubscribe.fromObject(data.unsubscribeMessage);
        }
        if (data.sendMessage != null) {
            message.sendMessage = Send.fromObject(data.sendMessage);
        }
        if (data.receiveMessage != null) {
            message.receiveMessage = Receive.fromObject(data.receiveMessage);
        }
        if (data.fetchMessage != null) {
            message.fetchMessage = Fetch.fromObject(data.fetchMessage);
        }
        if (data.disconnectMessage != null) {
            message.disconnectMessage = Disconnect.fromObject(data.disconnectMessage);
        }
        if (data.connectMessage != null) {
            message.connectMessage = Connect.fromObject(data.connectMessage);
        }
        if (data.notifyMessage != null) {
            message.notifyMessage = Notify.fromObject(data.notifyMessage);
        }
        return message;
    }
    toObject() {
        const data: {
            protocolMsgType?: ProtocolMessageType;
            subscribeMessage?: ReturnType<typeof Subscribe.prototype.toObject>;
            unsubscribeMessage?: ReturnType<typeof Unsubscribe.prototype.toObject>;
            sendMessage?: ReturnType<typeof Send.prototype.toObject>;
            receiveMessage?: ReturnType<typeof Receive.prototype.toObject>;
            fetchMessage?: ReturnType<typeof Fetch.prototype.toObject>;
            disconnectMessage?: ReturnType<typeof Disconnect.prototype.toObject>;
            connectMessage?: ReturnType<typeof Connect.prototype.toObject>;
            notifyMessage?: ReturnType<typeof Notify.prototype.toObject>;
        } = {};
        if (this.protocolMsgType != null) {
            data.protocolMsgType = this.protocolMsgType;
        }
        if (this.subscribeMessage != null) {
            data.subscribeMessage = this.subscribeMessage.toObject();
        }
        if (this.unsubscribeMessage != null) {
            data.unsubscribeMessage = this.unsubscribeMessage.toObject();
        }
        if (this.sendMessage != null) {
            data.sendMessage = this.sendMessage.toObject();
        }
        if (this.receiveMessage != null) {
            data.receiveMessage = this.receiveMessage.toObject();
        }
        if (this.fetchMessage != null) {
            data.fetchMessage = this.fetchMessage.toObject();
        }
        if (this.disconnectMessage != null) {
            data.disconnectMessage = this.disconnectMessage.toObject();
        }
        if (this.connectMessage != null) {
            data.connectMessage = this.connectMessage.toObject();
        }
        if (this.notifyMessage != null) {
            data.notifyMessage = this.notifyMessage.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.protocolMsgType != ProtocolMessageType.UNSPECIFIED)
            writer.writeEnum(1, this.protocolMsgType);
        if (this.has_subscribeMessage)
            writer.writeMessage(2, this.subscribeMessage, () => this.subscribeMessage.serialize(writer));
        if (this.has_unsubscribeMessage)
            writer.writeMessage(3, this.unsubscribeMessage, () => this.unsubscribeMessage.serialize(writer));
        if (this.has_sendMessage)
            writer.writeMessage(4, this.sendMessage, () => this.sendMessage.serialize(writer));
        if (this.has_receiveMessage)
            writer.writeMessage(5, this.receiveMessage, () => this.receiveMessage.serialize(writer));
        if (this.has_fetchMessage)
            writer.writeMessage(6, this.fetchMessage, () => this.fetchMessage.serialize(writer));
        if (this.has_disconnectMessage)
            writer.writeMessage(7, this.disconnectMessage, () => this.disconnectMessage.serialize(writer));
        if (this.has_connectMessage)
            writer.writeMessage(8, this.connectMessage, () => this.connectMessage.serialize(writer));
        if (this.has_notifyMessage)
            writer.writeMessage(9, this.notifyMessage, () => this.notifyMessage.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ProtocolMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ProtocolMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.protocolMsgType = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.subscribeMessage, () => message.subscribeMessage = Subscribe.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.unsubscribeMessage, () => message.unsubscribeMessage = Unsubscribe.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.sendMessage, () => message.sendMessage = Send.deserialize(reader));
                    break;
                case 5:
                    reader.readMessage(message.receiveMessage, () => message.receiveMessage = Receive.deserialize(reader));
                    break;
                case 6:
                    reader.readMessage(message.fetchMessage, () => message.fetchMessage = Fetch.deserialize(reader));
                    break;
                case 7:
                    reader.readMessage(message.disconnectMessage, () => message.disconnectMessage = Disconnect.deserialize(reader));
                    break;
                case 8:
                    reader.readMessage(message.connectMessage, () => message.connectMessage = Connect.deserialize(reader));
                    break;
                case 9:
                    reader.readMessage(message.notifyMessage, () => message.notifyMessage = Notify.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ProtocolMessage {
        return ProtocolMessage.deserialize(bytes);
    }
}
export class Subscribe extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2]];
    constructor(data?: any[] | ({} & (({
        subject?: string;
        directMessages?: never;
    } | {
        subject?: never;
        directMessages?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("subject" in data && data.subject != undefined) {
                this.subject = data.subject;
            }
            if ("directMessages" in data && data.directMessages != undefined) {
                this.directMessages = data.directMessages;
            }
        }
    }
    get subject() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set subject(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_subject() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get directMessages() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set directMessages(value: boolean) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
    }
    get has_directMessages() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get subjectOrDirectMessages() {
        const cases: {
            [index: number]: "none" | "subject" | "directMessages";
        } = {
            0: "none",
            1: "subject",
            2: "directMessages"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    static fromObject(data: {
        subject?: string;
        directMessages?: boolean;
    }): Subscribe {
        const message = new Subscribe({});
        if (data.subject != null) {
            message.subject = data.subject;
        }
        if (data.directMessages != null) {
            message.directMessages = data.directMessages;
        }
        return message;
    }
    toObject() {
        const data: {
            subject?: string;
            directMessages?: boolean;
        } = {};
        if (this.subject != null) {
            data.subject = this.subject;
        }
        if (this.directMessages != null) {
            data.directMessages = this.directMessages;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_subject)
            writer.writeString(1, this.subject);
        if (this.has_directMessages)
            writer.writeBool(2, this.directMessages);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Subscribe {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Subscribe();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.subject = reader.readString();
                    break;
                case 2:
                    message.directMessages = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Subscribe {
        return Subscribe.deserialize(bytes);
    }
}
export class Unsubscribe extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2]];
    constructor(data?: any[] | ({} & (({
        subject?: string;
        directMessages?: never;
    } | {
        subject?: never;
        directMessages?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("subject" in data && data.subject != undefined) {
                this.subject = data.subject;
            }
            if ("directMessages" in data && data.directMessages != undefined) {
                this.directMessages = data.directMessages;
            }
        }
    }
    get subject() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set subject(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_subject() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get directMessages() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set directMessages(value: boolean) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
    }
    get has_directMessages() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get subjectOrDirectMessages() {
        const cases: {
            [index: number]: "none" | "subject" | "directMessages";
        } = {
            0: "none",
            1: "subject",
            2: "directMessages"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    static fromObject(data: {
        subject?: string;
        directMessages?: boolean;
    }): Unsubscribe {
        const message = new Unsubscribe({});
        if (data.subject != null) {
            message.subject = data.subject;
        }
        if (data.directMessages != null) {
            message.directMessages = data.directMessages;
        }
        return message;
    }
    toObject() {
        const data: {
            subject?: string;
            directMessages?: boolean;
        } = {};
        if (this.subject != null) {
            data.subject = this.subject;
        }
        if (this.directMessages != null) {
            data.directMessages = this.directMessages;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_subject)
            writer.writeString(1, this.subject);
        if (this.has_directMessages)
            writer.writeBool(2, this.directMessages);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Unsubscribe {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Unsubscribe();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.subject = reader.readString();
                    break;
                case 2:
                    message.directMessages = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Unsubscribe {
        return Unsubscribe.deserialize(bytes);
    }
}
export class Send extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        applicationMessage?: ApplicationMessage;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("applicationMessage" in data && data.applicationMessage != undefined) {
                this.applicationMessage = data.applicationMessage;
            }
        }
    }
    get applicationMessage() {
        return pb_1.Message.getWrapperField(this, ApplicationMessage, 1) as ApplicationMessage;
    }
    set applicationMessage(value: ApplicationMessage) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get has_applicationMessage() {
        return pb_1.Message.getField(this, 1) != null;
    }
    static fromObject(data: {
        applicationMessage?: ReturnType<typeof ApplicationMessage.prototype.toObject>;
    }): Send {
        const message = new Send({});
        if (data.applicationMessage != null) {
            message.applicationMessage = ApplicationMessage.fromObject(data.applicationMessage);
        }
        return message;
    }
    toObject() {
        const data: {
            applicationMessage?: ReturnType<typeof ApplicationMessage.prototype.toObject>;
        } = {};
        if (this.applicationMessage != null) {
            data.applicationMessage = this.applicationMessage.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_applicationMessage)
            writer.writeMessage(1, this.applicationMessage, () => this.applicationMessage.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Send {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Send();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.applicationMessage, () => message.applicationMessage = ApplicationMessage.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Send {
        return Send.deserialize(bytes);
    }
}
export class Receive extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({} & (({
        filter?: Filter;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("filter" in data && data.filter != undefined) {
                this.filter = data.filter;
            }
        }
    }
    get filter() {
        return pb_1.Message.getWrapperField(this, Filter, 1) as Filter;
    }
    set filter(value: Filter) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_filter() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get _filter() {
        const cases: {
            [index: number]: "none" | "filter";
        } = {
            0: "none",
            1: "filter"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        filter?: ReturnType<typeof Filter.prototype.toObject>;
    }): Receive {
        const message = new Receive({});
        if (data.filter != null) {
            message.filter = Filter.fromObject(data.filter);
        }
        return message;
    }
    toObject() {
        const data: {
            filter?: ReturnType<typeof Filter.prototype.toObject>;
        } = {};
        if (this.filter != null) {
            data.filter = this.filter.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_filter)
            writer.writeMessage(1, this.filter, () => this.filter.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Receive {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Receive();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.filter, () => message.filter = Filter.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Receive {
        return Receive.deserialize(bytes);
    }
}
export class Filter extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        messageUuids?: string[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("messageUuids" in data && data.messageUuids != undefined) {
                this.messageUuids = data.messageUuids;
            }
        }
    }
    get messageUuids() {
        return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
    }
    set messageUuids(value: string[]) {
        pb_1.Message.setField(this, 1, value);
    }
    static fromObject(data: {
        messageUuids?: string[];
    }): Filter {
        const message = new Filter({});
        if (data.messageUuids != null) {
            message.messageUuids = data.messageUuids;
        }
        return message;
    }
    toObject() {
        const data: {
            messageUuids?: string[];
        } = {};
        if (this.messageUuids != null) {
            data.messageUuids = this.messageUuids;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.messageUuids.length)
            writer.writeRepeatedString(1, this.messageUuids);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Filter {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Filter();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Filter {
        return Filter.deserialize(bytes);
    }
}
export class Fetch extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): Fetch {
        const message = new Fetch({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Fetch {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Fetch();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Fetch {
        return Fetch.deserialize(bytes);
    }
}
export class Disconnect extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {}) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") { }
    }
    static fromObject(data: {}): Disconnect {
        const message = new Disconnect({});
        return message;
    }
    toObject() {
        const data: {} = {};
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Disconnect {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Disconnect();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Disconnect {
        return Disconnect.deserialize(bytes);
    }
}
export class Connect extends pb_1.Message {
    #one_of_decls: number[][] = [[1], [2]];
    constructor(data?: any[] | ({} & (({
        ownMrn?: string;
    }) | ({
        reconnectToken?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("ownMrn" in data && data.ownMrn != undefined) {
                this.ownMrn = data.ownMrn;
            }
            if ("reconnectToken" in data && data.reconnectToken != undefined) {
                this.reconnectToken = data.reconnectToken;
            }
        }
    }
    get ownMrn() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set ownMrn(value: string) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_ownMrn() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get reconnectToken() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set reconnectToken(value: string) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[1], value);
    }
    get has_reconnectToken() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _ownMrn() {
        const cases: {
            [index: number]: "none" | "ownMrn";
        } = {
            0: "none",
            1: "ownMrn"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    get _reconnectToken() {
        const cases: {
            [index: number]: "none" | "reconnectToken";
        } = {
            0: "none",
            2: "reconnectToken"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        ownMrn?: string;
        reconnectToken?: string;
    }): Connect {
        const message = new Connect({});
        if (data.ownMrn != null) {
            message.ownMrn = data.ownMrn;
        }
        if (data.reconnectToken != null) {
            message.reconnectToken = data.reconnectToken;
        }
        return message;
    }
    toObject() {
        const data: {
            ownMrn?: string;
            reconnectToken?: string;
        } = {};
        if (this.ownMrn != null) {
            data.ownMrn = this.ownMrn;
        }
        if (this.reconnectToken != null) {
            data.reconnectToken = this.reconnectToken;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_ownMrn)
            writer.writeString(1, this.ownMrn);
        if (this.has_reconnectToken)
            writer.writeString(2, this.reconnectToken);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Connect {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Connect();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.ownMrn = reader.readString();
                    break;
                case 2:
                    message.reconnectToken = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Connect {
        return Connect.deserialize(bytes);
    }
}
export class Notify extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        messageMetadata?: MessageMetadata[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("messageMetadata" in data && data.messageMetadata != undefined) {
                this.messageMetadata = data.messageMetadata;
            }
        }
    }
    get messageMetadata() {
        return pb_1.Message.getRepeatedWrapperField(this, MessageMetadata, 1) as MessageMetadata[];
    }
    set messageMetadata(value: MessageMetadata[]) {
        pb_1.Message.setRepeatedWrapperField(this, 1, value);
    }
    static fromObject(data: {
        messageMetadata?: ReturnType<typeof MessageMetadata.prototype.toObject>[];
    }): Notify {
        const message = new Notify({});
        if (data.messageMetadata != null) {
            message.messageMetadata = data.messageMetadata.map(item => MessageMetadata.fromObject(item));
        }
        return message;
    }
    toObject() {
        const data: {
            messageMetadata?: ReturnType<typeof MessageMetadata.prototype.toObject>[];
        } = {};
        if (this.messageMetadata != null) {
            data.messageMetadata = this.messageMetadata.map((item: MessageMetadata) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.messageMetadata.length)
            writer.writeRepeatedMessage(1, this.messageMetadata, (item: MessageMetadata) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Notify {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Notify();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.messageMetadata, () => pb_1.Message.addToRepeatedWrapperField(message, 1, MessageMetadata.deserialize(reader), MessageMetadata));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Notify {
        return Notify.deserialize(bytes);
    }
}
export class ResponseMessage extends pb_1.Message {
    #one_of_decls: number[][] = [[3], [6]];
    constructor(data?: any[] | ({
        responseToUuid?: string;
        response?: ResponseEnum;
        messageMetadata?: MessageMetadata[];
        messageContent?: MessageContent[];
    } & (({
        reasonText?: string;
    }) | ({
        reconnectToken?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 5], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("responseToUuid" in data && data.responseToUuid != undefined) {
                this.responseToUuid = data.responseToUuid;
            }
            if ("response" in data && data.response != undefined) {
                this.response = data.response;
            }
            if ("reasonText" in data && data.reasonText != undefined) {
                this.reasonText = data.reasonText;
            }
            if ("messageMetadata" in data && data.messageMetadata != undefined) {
                this.messageMetadata = data.messageMetadata;
            }
            if ("messageContent" in data && data.messageContent != undefined) {
                this.messageContent = data.messageContent;
            }
            if ("reconnectToken" in data && data.reconnectToken != undefined) {
                this.reconnectToken = data.reconnectToken;
            }
        }
    }
    get responseToUuid() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set responseToUuid(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get response() {
        return pb_1.Message.getFieldWithDefault(this, 2, ResponseEnum.UNSPECIFIED_RESPONSE) as ResponseEnum;
    }
    set response(value: ResponseEnum) {
        pb_1.Message.setField(this, 2, value);
    }
    get reasonText() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set reasonText(value: string) {
        pb_1.Message.setOneofField(this, 3, this.#one_of_decls[0], value);
    }
    get has_reasonText() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get messageMetadata() {
        return pb_1.Message.getRepeatedWrapperField(this, MessageMetadata, 4) as MessageMetadata[];
    }
    set messageMetadata(value: MessageMetadata[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    get messageContent() {
        return pb_1.Message.getRepeatedWrapperField(this, MessageContent, 5) as MessageContent[];
    }
    set messageContent(value: MessageContent[]) {
        pb_1.Message.setRepeatedWrapperField(this, 5, value);
    }
    get reconnectToken() {
        return pb_1.Message.getFieldWithDefault(this, 6, "") as string;
    }
    set reconnectToken(value: string) {
        pb_1.Message.setOneofField(this, 6, this.#one_of_decls[1], value);
    }
    get has_reconnectToken() {
        return pb_1.Message.getField(this, 6) != null;
    }
    get _reasonText() {
        const cases: {
            [index: number]: "none" | "reasonText";
        } = {
            0: "none",
            3: "reasonText"
        };
        return cases[pb_1.Message.computeOneofCase(this, [3])];
    }
    get _reconnectToken() {
        const cases: {
            [index: number]: "none" | "reconnectToken";
        } = {
            0: "none",
            6: "reconnectToken"
        };
        return cases[pb_1.Message.computeOneofCase(this, [6])];
    }
    static fromObject(data: {
        responseToUuid?: string;
        response?: ResponseEnum;
        reasonText?: string;
        messageMetadata?: ReturnType<typeof MessageMetadata.prototype.toObject>[];
        messageContent?: ReturnType<typeof MessageContent.prototype.toObject>[];
        reconnectToken?: string;
    }): ResponseMessage {
        const message = new ResponseMessage({});
        if (data.responseToUuid != null) {
            message.responseToUuid = data.responseToUuid;
        }
        if (data.response != null) {
            message.response = data.response;
        }
        if (data.reasonText != null) {
            message.reasonText = data.reasonText;
        }
        if (data.messageMetadata != null) {
            message.messageMetadata = data.messageMetadata.map(item => MessageMetadata.fromObject(item));
        }
        if (data.messageContent != null) {
            message.messageContent = data.messageContent.map(item => MessageContent.fromObject(item));
        }
        if (data.reconnectToken != null) {
            message.reconnectToken = data.reconnectToken;
        }
        return message;
    }
    toObject() {
        const data: {
            responseToUuid?: string;
            response?: ResponseEnum;
            reasonText?: string;
            messageMetadata?: ReturnType<typeof MessageMetadata.prototype.toObject>[];
            messageContent?: ReturnType<typeof MessageContent.prototype.toObject>[];
            reconnectToken?: string;
        } = {};
        if (this.responseToUuid != null) {
            data.responseToUuid = this.responseToUuid;
        }
        if (this.response != null) {
            data.response = this.response;
        }
        if (this.reasonText != null) {
            data.reasonText = this.reasonText;
        }
        if (this.messageMetadata != null) {
            data.messageMetadata = this.messageMetadata.map((item: MessageMetadata) => item.toObject());
        }
        if (this.messageContent != null) {
            data.messageContent = this.messageContent.map((item: MessageContent) => item.toObject());
        }
        if (this.reconnectToken != null) {
            data.reconnectToken = this.reconnectToken;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.responseToUuid.length)
            writer.writeString(1, this.responseToUuid);
        if (this.response != ResponseEnum.UNSPECIFIED_RESPONSE)
            writer.writeEnum(2, this.response);
        if (this.has_reasonText)
            writer.writeString(3, this.reasonText);
        if (this.messageMetadata.length)
            writer.writeRepeatedMessage(4, this.messageMetadata, (item: MessageMetadata) => item.serialize(writer));
        if (this.messageContent.length)
            writer.writeRepeatedMessage(5, this.messageContent, (item: MessageContent) => item.serialize(writer));
        if (this.has_reconnectToken)
            writer.writeString(6, this.reconnectToken);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ResponseMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ResponseMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.responseToUuid = reader.readString();
                    break;
                case 2:
                    message.response = reader.readEnum();
                    break;
                case 3:
                    message.reasonText = reader.readString();
                    break;
                case 4:
                    reader.readMessage(message.messageMetadata, () => pb_1.Message.addToRepeatedWrapperField(message, 4, MessageMetadata.deserialize(reader), MessageMetadata));
                    break;
                case 5:
                    reader.readMessage(message.messageContent, () => pb_1.Message.addToRepeatedWrapperField(message, 5, MessageContent.deserialize(reader), MessageContent));
                    break;
                case 6:
                    message.reconnectToken = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ResponseMessage {
        return ResponseMessage.deserialize(bytes);
    }
}
export class MessageMetadata extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        uuid?: string;
        header?: ApplicationMessageHeader;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("uuid" in data && data.uuid != undefined) {
                this.uuid = data.uuid;
            }
            if ("header" in data && data.header != undefined) {
                this.header = data.header;
            }
        }
    }
    get uuid() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set uuid(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get header() {
        return pb_1.Message.getWrapperField(this, ApplicationMessageHeader, 2) as ApplicationMessageHeader;
    }
    set header(value: ApplicationMessageHeader) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_header() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        uuid?: string;
        header?: ReturnType<typeof ApplicationMessageHeader.prototype.toObject>;
    }): MessageMetadata {
        const message = new MessageMetadata({});
        if (data.uuid != null) {
            message.uuid = data.uuid;
        }
        if (data.header != null) {
            message.header = ApplicationMessageHeader.fromObject(data.header);
        }
        return message;
    }
    toObject() {
        const data: {
            uuid?: string;
            header?: ReturnType<typeof ApplicationMessageHeader.prototype.toObject>;
        } = {};
        if (this.uuid != null) {
            data.uuid = this.uuid;
        }
        if (this.header != null) {
            data.header = this.header.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.uuid.length)
            writer.writeString(1, this.uuid);
        if (this.has_header)
            writer.writeMessage(2, this.header, () => this.header.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MessageMetadata {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MessageMetadata();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.uuid = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.header, () => message.header = ApplicationMessageHeader.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MessageMetadata {
        return MessageMetadata.deserialize(bytes);
    }
}
export class MessageContent extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        uuid?: string;
        msg?: ApplicationMessage;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("uuid" in data && data.uuid != undefined) {
                this.uuid = data.uuid;
            }
            if ("msg" in data && data.msg != undefined) {
                this.msg = data.msg;
            }
        }
    }
    get uuid() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set uuid(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get msg() {
        return pb_1.Message.getWrapperField(this, ApplicationMessage, 2) as ApplicationMessage;
    }
    set msg(value: ApplicationMessage) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_msg() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        uuid?: string;
        msg?: ReturnType<typeof ApplicationMessage.prototype.toObject>;
    }): MessageContent {
        const message = new MessageContent({});
        if (data.uuid != null) {
            message.uuid = data.uuid;
        }
        if (data.msg != null) {
            message.msg = ApplicationMessage.fromObject(data.msg);
        }
        return message;
    }
    toObject() {
        const data: {
            uuid?: string;
            msg?: ReturnType<typeof ApplicationMessage.prototype.toObject>;
        } = {};
        if (this.uuid != null) {
            data.uuid = this.uuid;
        }
        if (this.msg != null) {
            data.msg = this.msg.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.uuid.length)
            writer.writeString(1, this.uuid);
        if (this.has_msg)
            writer.writeMessage(2, this.msg, () => this.msg.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): MessageContent {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new MessageContent();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.uuid = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.msg, () => message.msg = ApplicationMessage.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): MessageContent {
        return MessageContent.deserialize(bytes);
    }
}
