// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: mmtp.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "";

export enum MsgType {
  UNSPECIFIED_MESSAGE = 0,
  PROTOCOL_MESSAGE = 1,
  RESPONSE_MESSAGE = 2,
  UNRECOGNIZED = -1,
}

export function msgTypeFromJSON(object: any): MsgType {
  switch (object) {
    case 0:
    case "UNSPECIFIED_MESSAGE":
      return MsgType.UNSPECIFIED_MESSAGE;
    case 1:
    case "PROTOCOL_MESSAGE":
      return MsgType.PROTOCOL_MESSAGE;
    case 2:
    case "RESPONSE_MESSAGE":
      return MsgType.RESPONSE_MESSAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MsgType.UNRECOGNIZED;
  }
}

export function msgTypeToJSON(object: MsgType): string {
  switch (object) {
    case MsgType.UNSPECIFIED_MESSAGE:
      return "UNSPECIFIED_MESSAGE";
    case MsgType.PROTOCOL_MESSAGE:
      return "PROTOCOL_MESSAGE";
    case MsgType.RESPONSE_MESSAGE:
      return "RESPONSE_MESSAGE";
    case MsgType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ProtocolMessageType {
  UNSPECIFIED = 0,
  SUBSCRIBE_MESSAGE = 1,
  UNSUBSCRIBE_MESSAGE = 2,
  SEND_MESSAGE = 3,
  RECEIVE_MESSAGE = 4,
  FETCH_MESSAGE = 5,
  DISCONNECT_MESSAGE = 6,
  CONNECT_MESSAGE = 7,
  NOTIFY_MESSAGE = 8,
  UNRECOGNIZED = -1,
}

export function protocolMessageTypeFromJSON(object: any): ProtocolMessageType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return ProtocolMessageType.UNSPECIFIED;
    case 1:
    case "SUBSCRIBE_MESSAGE":
      return ProtocolMessageType.SUBSCRIBE_MESSAGE;
    case 2:
    case "UNSUBSCRIBE_MESSAGE":
      return ProtocolMessageType.UNSUBSCRIBE_MESSAGE;
    case 3:
    case "SEND_MESSAGE":
      return ProtocolMessageType.SEND_MESSAGE;
    case 4:
    case "RECEIVE_MESSAGE":
      return ProtocolMessageType.RECEIVE_MESSAGE;
    case 5:
    case "FETCH_MESSAGE":
      return ProtocolMessageType.FETCH_MESSAGE;
    case 6:
    case "DISCONNECT_MESSAGE":
      return ProtocolMessageType.DISCONNECT_MESSAGE;
    case 7:
    case "CONNECT_MESSAGE":
      return ProtocolMessageType.CONNECT_MESSAGE;
    case 8:
    case "NOTIFY_MESSAGE":
      return ProtocolMessageType.NOTIFY_MESSAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ProtocolMessageType.UNRECOGNIZED;
  }
}

export function protocolMessageTypeToJSON(object: ProtocolMessageType): string {
  switch (object) {
    case ProtocolMessageType.UNSPECIFIED:
      return "UNSPECIFIED";
    case ProtocolMessageType.SUBSCRIBE_MESSAGE:
      return "SUBSCRIBE_MESSAGE";
    case ProtocolMessageType.UNSUBSCRIBE_MESSAGE:
      return "UNSUBSCRIBE_MESSAGE";
    case ProtocolMessageType.SEND_MESSAGE:
      return "SEND_MESSAGE";
    case ProtocolMessageType.RECEIVE_MESSAGE:
      return "RECEIVE_MESSAGE";
    case ProtocolMessageType.FETCH_MESSAGE:
      return "FETCH_MESSAGE";
    case ProtocolMessageType.DISCONNECT_MESSAGE:
      return "DISCONNECT_MESSAGE";
    case ProtocolMessageType.CONNECT_MESSAGE:
      return "CONNECT_MESSAGE";
    case ProtocolMessageType.NOTIFY_MESSAGE:
      return "NOTIFY_MESSAGE";
    case ProtocolMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ResponseEnum {
  UNSPECIFIED_RESPONSE = 0,
  GOOD = 1,
  ERROR = 2,
  UNRECOGNIZED = -1,
}

export function responseEnumFromJSON(object: any): ResponseEnum {
  switch (object) {
    case 0:
    case "UNSPECIFIED_RESPONSE":
      return ResponseEnum.UNSPECIFIED_RESPONSE;
    case 1:
    case "GOOD":
      return ResponseEnum.GOOD;
    case 2:
    case "ERROR":
      return ResponseEnum.ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResponseEnum.UNRECOGNIZED;
  }
}

export function responseEnumToJSON(object: ResponseEnum): string {
  switch (object) {
    case ResponseEnum.UNSPECIFIED_RESPONSE:
      return "UNSPECIFIED_RESPONSE";
    case ResponseEnum.GOOD:
      return "GOOD";
    case ResponseEnum.ERROR:
      return "ERROR";
    case ResponseEnum.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ApplicationMessage {
  header: ApplicationMessageHeader | undefined;
  body: Uint8Array;
  signature: Uint8Array;
}

export interface ApplicationMessageHeader {
  subject?: string | undefined;
  recipients?: Recipients | undefined;
  expires: number;
  sender: string;
  qosProfile?: string | undefined;
  bodySizeNumBytes: number;
}

export interface Recipients {
  recipients: string[];
}

export interface MmtpMessage {
  msgType: MsgType;
  uuid: string;
  protocolMessage?: ProtocolMessage | undefined;
  responseMessage?: ResponseMessage | undefined;
}

export interface ProtocolMessage {
  protocolMsgType: ProtocolMessageType;
  subscribeMessage?: Subscribe | undefined;
  unsubscribeMessage?: Unsubscribe | undefined;
  sendMessage?: Send | undefined;
  receiveMessage?: Receive | undefined;
  fetchMessage?: Fetch | undefined;
  disconnectMessage?: Disconnect | undefined;
  connectMessage?: Connect | undefined;
  notifyMessage?: Notify | undefined;
}

export interface Subscribe {
  subject?: string | undefined;
  directMessages?: boolean | undefined;
}

export interface Unsubscribe {
  subject?: string | undefined;
  directMessages?: boolean | undefined;
}

export interface Send {
  applicationMessage: ApplicationMessage | undefined;
}

export interface Receive {
  filter?: Filter | undefined;
}

export interface Filter {
  messageUuids: string[];
}

export interface Fetch {
}

export interface Disconnect {
}

export interface Connect {
  ownMrn?: string | undefined;
  reconnectToken?: string | undefined;
}

export interface Notify {
  messageMetadata: MessageMetadata[];
}

export interface ResponseMessage {
  responseToUuid: string;
  response: ResponseEnum;
  reasonText?: string | undefined;
  messageMetadata: MessageMetadata[];
  messageContent: MessageContent[];
  reconnectToken?: string | undefined;
}

export interface MessageMetadata {
  uuid: string;
  header: ApplicationMessageHeader | undefined;
}

export interface MessageContent {
  uuid: string;
  msg: ApplicationMessage | undefined;
}

function createBaseApplicationMessage(): ApplicationMessage {
  return { header: undefined, body: new Uint8Array(0), signature: new Uint8Array(0) };
}

export const ApplicationMessage: MessageFns<ApplicationMessage> = {
  encode(message: ApplicationMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== undefined) {
      ApplicationMessageHeader.encode(message.header, writer.uint32(10).fork()).join();
    }
    if (message.body.length !== 0) {
      writer.uint32(18).bytes(message.body);
    }
    if (message.signature.length !== 0) {
      writer.uint32(26).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = ApplicationMessageHeader.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.body = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationMessage {
    return {
      header: isSet(object.header) ? ApplicationMessageHeader.fromJSON(object.header) : undefined,
      body: isSet(object.body) ? bytesFromBase64(object.body) : new Uint8Array(0),
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: ApplicationMessage): unknown {
    const obj: any = {};
    if (message.header !== undefined) {
      obj.header = ApplicationMessageHeader.toJSON(message.header);
    }
    if (message.body.length !== 0) {
      obj.body = base64FromBytes(message.body);
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationMessage>, I>>(base?: I): ApplicationMessage {
    return ApplicationMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationMessage>, I>>(object: I): ApplicationMessage {
    const message = createBaseApplicationMessage();
    message.header = (object.header !== undefined && object.header !== null)
      ? ApplicationMessageHeader.fromPartial(object.header)
      : undefined;
    message.body = object.body ?? new Uint8Array(0);
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseApplicationMessageHeader(): ApplicationMessageHeader {
  return {
    subject: undefined,
    recipients: undefined,
    expires: 0,
    sender: "",
    qosProfile: undefined,
    bodySizeNumBytes: 0,
  };
}

export const ApplicationMessageHeader: MessageFns<ApplicationMessageHeader> = {
  encode(message: ApplicationMessageHeader, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      writer.uint32(10).string(message.subject);
    }
    if (message.recipients !== undefined) {
      Recipients.encode(message.recipients, writer.uint32(18).fork()).join();
    }
    if (message.expires !== 0) {
      writer.uint32(24).int64(message.expires);
    }
    if (message.sender !== "") {
      writer.uint32(34).string(message.sender);
    }
    if (message.qosProfile !== undefined) {
      writer.uint32(42).string(message.qosProfile);
    }
    if (message.bodySizeNumBytes !== 0) {
      writer.uint32(48).uint32(message.bodySizeNumBytes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApplicationMessageHeader {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApplicationMessageHeader();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipients = Recipients.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expires = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.qosProfile = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.bodySizeNumBytes = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApplicationMessageHeader {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      recipients: isSet(object.recipients) ? Recipients.fromJSON(object.recipients) : undefined,
      expires: isSet(object.expires) ? globalThis.Number(object.expires) : 0,
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      qosProfile: isSet(object.qosProfile) ? globalThis.String(object.qosProfile) : undefined,
      bodySizeNumBytes: isSet(object.bodySizeNumBytes) ? globalThis.Number(object.bodySizeNumBytes) : 0,
    };
  },

  toJSON(message: ApplicationMessageHeader): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.recipients !== undefined) {
      obj.recipients = Recipients.toJSON(message.recipients);
    }
    if (message.expires !== 0) {
      obj.expires = Math.round(message.expires);
    }
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.qosProfile !== undefined) {
      obj.qosProfile = message.qosProfile;
    }
    if (message.bodySizeNumBytes !== 0) {
      obj.bodySizeNumBytes = Math.round(message.bodySizeNumBytes);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ApplicationMessageHeader>, I>>(base?: I): ApplicationMessageHeader {
    return ApplicationMessageHeader.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ApplicationMessageHeader>, I>>(object: I): ApplicationMessageHeader {
    const message = createBaseApplicationMessageHeader();
    message.subject = object.subject ?? undefined;
    message.recipients = (object.recipients !== undefined && object.recipients !== null)
      ? Recipients.fromPartial(object.recipients)
      : undefined;
    message.expires = object.expires ?? 0;
    message.sender = object.sender ?? "";
    message.qosProfile = object.qosProfile ?? undefined;
    message.bodySizeNumBytes = object.bodySizeNumBytes ?? 0;
    return message;
  },
};

function createBaseRecipients(): Recipients {
  return { recipients: [] };
}

export const Recipients: MessageFns<Recipients> = {
  encode(message: Recipients, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.recipients) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recipients {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecipients();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipients.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recipients {
    return {
      recipients: globalThis.Array.isArray(object?.recipients)
        ? object.recipients.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Recipients): unknown {
    const obj: any = {};
    if (message.recipients?.length) {
      obj.recipients = message.recipients;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Recipients>, I>>(base?: I): Recipients {
    return Recipients.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Recipients>, I>>(object: I): Recipients {
    const message = createBaseRecipients();
    message.recipients = object.recipients?.map((e) => e) || [];
    return message;
  },
};

function createBaseMmtpMessage(): MmtpMessage {
  return { msgType: 0, uuid: "", protocolMessage: undefined, responseMessage: undefined };
}

export const MmtpMessage: MessageFns<MmtpMessage> = {
  encode(message: MmtpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.msgType !== 0) {
      writer.uint32(8).int32(message.msgType);
    }
    if (message.uuid !== "") {
      writer.uint32(18).string(message.uuid);
    }
    if (message.protocolMessage !== undefined) {
      ProtocolMessage.encode(message.protocolMessage, writer.uint32(26).fork()).join();
    }
    if (message.responseMessage !== undefined) {
      ResponseMessage.encode(message.responseMessage, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MmtpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMmtpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.protocolMessage = ProtocolMessage.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.responseMessage = ResponseMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MmtpMessage {
    return {
      msgType: isSet(object.msgType) ? msgTypeFromJSON(object.msgType) : 0,
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      protocolMessage: isSet(object.protocolMessage) ? ProtocolMessage.fromJSON(object.protocolMessage) : undefined,
      responseMessage: isSet(object.responseMessage) ? ResponseMessage.fromJSON(object.responseMessage) : undefined,
    };
  },

  toJSON(message: MmtpMessage): unknown {
    const obj: any = {};
    if (message.msgType !== 0) {
      obj.msgType = msgTypeToJSON(message.msgType);
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.protocolMessage !== undefined) {
      obj.protocolMessage = ProtocolMessage.toJSON(message.protocolMessage);
    }
    if (message.responseMessage !== undefined) {
      obj.responseMessage = ResponseMessage.toJSON(message.responseMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MmtpMessage>, I>>(base?: I): MmtpMessage {
    return MmtpMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MmtpMessage>, I>>(object: I): MmtpMessage {
    const message = createBaseMmtpMessage();
    message.msgType = object.msgType ?? 0;
    message.uuid = object.uuid ?? "";
    message.protocolMessage = (object.protocolMessage !== undefined && object.protocolMessage !== null)
      ? ProtocolMessage.fromPartial(object.protocolMessage)
      : undefined;
    message.responseMessage = (object.responseMessage !== undefined && object.responseMessage !== null)
      ? ResponseMessage.fromPartial(object.responseMessage)
      : undefined;
    return message;
  },
};

function createBaseProtocolMessage(): ProtocolMessage {
  return {
    protocolMsgType: 0,
    subscribeMessage: undefined,
    unsubscribeMessage: undefined,
    sendMessage: undefined,
    receiveMessage: undefined,
    fetchMessage: undefined,
    disconnectMessage: undefined,
    connectMessage: undefined,
    notifyMessage: undefined,
  };
}

export const ProtocolMessage: MessageFns<ProtocolMessage> = {
  encode(message: ProtocolMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocolMsgType !== 0) {
      writer.uint32(8).int32(message.protocolMsgType);
    }
    if (message.subscribeMessage !== undefined) {
      Subscribe.encode(message.subscribeMessage, writer.uint32(18).fork()).join();
    }
    if (message.unsubscribeMessage !== undefined) {
      Unsubscribe.encode(message.unsubscribeMessage, writer.uint32(26).fork()).join();
    }
    if (message.sendMessage !== undefined) {
      Send.encode(message.sendMessage, writer.uint32(34).fork()).join();
    }
    if (message.receiveMessage !== undefined) {
      Receive.encode(message.receiveMessage, writer.uint32(42).fork()).join();
    }
    if (message.fetchMessage !== undefined) {
      Fetch.encode(message.fetchMessage, writer.uint32(50).fork()).join();
    }
    if (message.disconnectMessage !== undefined) {
      Disconnect.encode(message.disconnectMessage, writer.uint32(58).fork()).join();
    }
    if (message.connectMessage !== undefined) {
      Connect.encode(message.connectMessage, writer.uint32(66).fork()).join();
    }
    if (message.notifyMessage !== undefined) {
      Notify.encode(message.notifyMessage, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProtocolMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProtocolMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocolMsgType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeMessage = Subscribe.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.unsubscribeMessage = Unsubscribe.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sendMessage = Send.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.receiveMessage = Receive.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fetchMessage = Fetch.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.disconnectMessage = Disconnect.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.connectMessage = Connect.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.notifyMessage = Notify.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProtocolMessage {
    return {
      protocolMsgType: isSet(object.protocolMsgType) ? protocolMessageTypeFromJSON(object.protocolMsgType) : 0,
      subscribeMessage: isSet(object.subscribeMessage) ? Subscribe.fromJSON(object.subscribeMessage) : undefined,
      unsubscribeMessage: isSet(object.unsubscribeMessage)
        ? Unsubscribe.fromJSON(object.unsubscribeMessage)
        : undefined,
      sendMessage: isSet(object.sendMessage) ? Send.fromJSON(object.sendMessage) : undefined,
      receiveMessage: isSet(object.receiveMessage) ? Receive.fromJSON(object.receiveMessage) : undefined,
      fetchMessage: isSet(object.fetchMessage) ? Fetch.fromJSON(object.fetchMessage) : undefined,
      disconnectMessage: isSet(object.disconnectMessage) ? Disconnect.fromJSON(object.disconnectMessage) : undefined,
      connectMessage: isSet(object.connectMessage) ? Connect.fromJSON(object.connectMessage) : undefined,
      notifyMessage: isSet(object.notifyMessage) ? Notify.fromJSON(object.notifyMessage) : undefined,
    };
  },

  toJSON(message: ProtocolMessage): unknown {
    const obj: any = {};
    if (message.protocolMsgType !== 0) {
      obj.protocolMsgType = protocolMessageTypeToJSON(message.protocolMsgType);
    }
    if (message.subscribeMessage !== undefined) {
      obj.subscribeMessage = Subscribe.toJSON(message.subscribeMessage);
    }
    if (message.unsubscribeMessage !== undefined) {
      obj.unsubscribeMessage = Unsubscribe.toJSON(message.unsubscribeMessage);
    }
    if (message.sendMessage !== undefined) {
      obj.sendMessage = Send.toJSON(message.sendMessage);
    }
    if (message.receiveMessage !== undefined) {
      obj.receiveMessage = Receive.toJSON(message.receiveMessage);
    }
    if (message.fetchMessage !== undefined) {
      obj.fetchMessage = Fetch.toJSON(message.fetchMessage);
    }
    if (message.disconnectMessage !== undefined) {
      obj.disconnectMessage = Disconnect.toJSON(message.disconnectMessage);
    }
    if (message.connectMessage !== undefined) {
      obj.connectMessage = Connect.toJSON(message.connectMessage);
    }
    if (message.notifyMessage !== undefined) {
      obj.notifyMessage = Notify.toJSON(message.notifyMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProtocolMessage>, I>>(base?: I): ProtocolMessage {
    return ProtocolMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProtocolMessage>, I>>(object: I): ProtocolMessage {
    const message = createBaseProtocolMessage();
    message.protocolMsgType = object.protocolMsgType ?? 0;
    message.subscribeMessage = (object.subscribeMessage !== undefined && object.subscribeMessage !== null)
      ? Subscribe.fromPartial(object.subscribeMessage)
      : undefined;
    message.unsubscribeMessage = (object.unsubscribeMessage !== undefined && object.unsubscribeMessage !== null)
      ? Unsubscribe.fromPartial(object.unsubscribeMessage)
      : undefined;
    message.sendMessage = (object.sendMessage !== undefined && object.sendMessage !== null)
      ? Send.fromPartial(object.sendMessage)
      : undefined;
    message.receiveMessage = (object.receiveMessage !== undefined && object.receiveMessage !== null)
      ? Receive.fromPartial(object.receiveMessage)
      : undefined;
    message.fetchMessage = (object.fetchMessage !== undefined && object.fetchMessage !== null)
      ? Fetch.fromPartial(object.fetchMessage)
      : undefined;
    message.disconnectMessage = (object.disconnectMessage !== undefined && object.disconnectMessage !== null)
      ? Disconnect.fromPartial(object.disconnectMessage)
      : undefined;
    message.connectMessage = (object.connectMessage !== undefined && object.connectMessage !== null)
      ? Connect.fromPartial(object.connectMessage)
      : undefined;
    message.notifyMessage = (object.notifyMessage !== undefined && object.notifyMessage !== null)
      ? Notify.fromPartial(object.notifyMessage)
      : undefined;
    return message;
  },
};

function createBaseSubscribe(): Subscribe {
  return { subject: undefined, directMessages: undefined };
}

export const Subscribe: MessageFns<Subscribe> = {
  encode(message: Subscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      writer.uint32(10).string(message.subject);
    }
    if (message.directMessages !== undefined) {
      writer.uint32(16).bool(message.directMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Subscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.directMessages = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Subscribe {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      directMessages: isSet(object.directMessages) ? globalThis.Boolean(object.directMessages) : undefined,
    };
  },

  toJSON(message: Subscribe): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.directMessages !== undefined) {
      obj.directMessages = message.directMessages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Subscribe>, I>>(base?: I): Subscribe {
    return Subscribe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Subscribe>, I>>(object: I): Subscribe {
    const message = createBaseSubscribe();
    message.subject = object.subject ?? undefined;
    message.directMessages = object.directMessages ?? undefined;
    return message;
  },
};

function createBaseUnsubscribe(): Unsubscribe {
  return { subject: undefined, directMessages: undefined };
}

export const Unsubscribe: MessageFns<Unsubscribe> = {
  encode(message: Unsubscribe, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== undefined) {
      writer.uint32(10).string(message.subject);
    }
    if (message.directMessages !== undefined) {
      writer.uint32(16).bool(message.directMessages);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Unsubscribe {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnsubscribe();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.directMessages = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Unsubscribe {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : undefined,
      directMessages: isSet(object.directMessages) ? globalThis.Boolean(object.directMessages) : undefined,
    };
  },

  toJSON(message: Unsubscribe): unknown {
    const obj: any = {};
    if (message.subject !== undefined) {
      obj.subject = message.subject;
    }
    if (message.directMessages !== undefined) {
      obj.directMessages = message.directMessages;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Unsubscribe>, I>>(base?: I): Unsubscribe {
    return Unsubscribe.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Unsubscribe>, I>>(object: I): Unsubscribe {
    const message = createBaseUnsubscribe();
    message.subject = object.subject ?? undefined;
    message.directMessages = object.directMessages ?? undefined;
    return message;
  },
};

function createBaseSend(): Send {
  return { applicationMessage: undefined };
}

export const Send: MessageFns<Send> = {
  encode(message: Send, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.applicationMessage !== undefined) {
      ApplicationMessage.encode(message.applicationMessage, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Send {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSend();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.applicationMessage = ApplicationMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Send {
    return {
      applicationMessage: isSet(object.applicationMessage)
        ? ApplicationMessage.fromJSON(object.applicationMessage)
        : undefined,
    };
  },

  toJSON(message: Send): unknown {
    const obj: any = {};
    if (message.applicationMessage !== undefined) {
      obj.applicationMessage = ApplicationMessage.toJSON(message.applicationMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Send>, I>>(base?: I): Send {
    return Send.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Send>, I>>(object: I): Send {
    const message = createBaseSend();
    message.applicationMessage = (object.applicationMessage !== undefined && object.applicationMessage !== null)
      ? ApplicationMessage.fromPartial(object.applicationMessage)
      : undefined;
    return message;
  },
};

function createBaseReceive(): Receive {
  return { filter: undefined };
}

export const Receive: MessageFns<Receive> = {
  encode(message: Receive, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filter !== undefined) {
      Filter.encode(message.filter, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Receive {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReceive();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filter = Filter.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Receive {
    return { filter: isSet(object.filter) ? Filter.fromJSON(object.filter) : undefined };
  },

  toJSON(message: Receive): unknown {
    const obj: any = {};
    if (message.filter !== undefined) {
      obj.filter = Filter.toJSON(message.filter);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Receive>, I>>(base?: I): Receive {
    return Receive.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Receive>, I>>(object: I): Receive {
    const message = createBaseReceive();
    message.filter = (object.filter !== undefined && object.filter !== null)
      ? Filter.fromPartial(object.filter)
      : undefined;
    return message;
  },
};

function createBaseFilter(): Filter {
  return { messageUuids: [] };
}

export const Filter: MessageFns<Filter> = {
  encode(message: Filter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messageUuids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Filter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageUuids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Filter {
    return {
      messageUuids: globalThis.Array.isArray(object?.messageUuids)
        ? object.messageUuids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: Filter): unknown {
    const obj: any = {};
    if (message.messageUuids?.length) {
      obj.messageUuids = message.messageUuids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Filter>, I>>(base?: I): Filter {
    return Filter.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Filter>, I>>(object: I): Filter {
    const message = createBaseFilter();
    message.messageUuids = object.messageUuids?.map((e) => e) || [];
    return message;
  },
};

function createBaseFetch(): Fetch {
  return {};
}

export const Fetch: MessageFns<Fetch> = {
  encode(_: Fetch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Fetch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFetch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Fetch {
    return {};
  },

  toJSON(_: Fetch): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Fetch>, I>>(base?: I): Fetch {
    return Fetch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Fetch>, I>>(_: I): Fetch {
    const message = createBaseFetch();
    return message;
  },
};

function createBaseDisconnect(): Disconnect {
  return {};
}

export const Disconnect: MessageFns<Disconnect> = {
  encode(_: Disconnect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Disconnect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDisconnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Disconnect {
    return {};
  },

  toJSON(_: Disconnect): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Disconnect>, I>>(base?: I): Disconnect {
    return Disconnect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Disconnect>, I>>(_: I): Disconnect {
    const message = createBaseDisconnect();
    return message;
  },
};

function createBaseConnect(): Connect {
  return { ownMrn: undefined, reconnectToken: undefined };
}

export const Connect: MessageFns<Connect> = {
  encode(message: Connect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ownMrn !== undefined) {
      writer.uint32(10).string(message.ownMrn);
    }
    if (message.reconnectToken !== undefined) {
      writer.uint32(18).string(message.reconnectToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Connect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ownMrn = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reconnectToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Connect {
    return {
      ownMrn: isSet(object.ownMrn) ? globalThis.String(object.ownMrn) : undefined,
      reconnectToken: isSet(object.reconnectToken) ? globalThis.String(object.reconnectToken) : undefined,
    };
  },

  toJSON(message: Connect): unknown {
    const obj: any = {};
    if (message.ownMrn !== undefined) {
      obj.ownMrn = message.ownMrn;
    }
    if (message.reconnectToken !== undefined) {
      obj.reconnectToken = message.reconnectToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Connect>, I>>(base?: I): Connect {
    return Connect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Connect>, I>>(object: I): Connect {
    const message = createBaseConnect();
    message.ownMrn = object.ownMrn ?? undefined;
    message.reconnectToken = object.reconnectToken ?? undefined;
    return message;
  },
};

function createBaseNotify(): Notify {
  return { messageMetadata: [] };
}

export const Notify: MessageFns<Notify> = {
  encode(message: Notify, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messageMetadata) {
      MessageMetadata.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Notify {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNotify();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageMetadata.push(MessageMetadata.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Notify {
    return {
      messageMetadata: globalThis.Array.isArray(object?.messageMetadata)
        ? object.messageMetadata.map((e: any) => MessageMetadata.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Notify): unknown {
    const obj: any = {};
    if (message.messageMetadata?.length) {
      obj.messageMetadata = message.messageMetadata.map((e) => MessageMetadata.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Notify>, I>>(base?: I): Notify {
    return Notify.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Notify>, I>>(object: I): Notify {
    const message = createBaseNotify();
    message.messageMetadata = object.messageMetadata?.map((e) => MessageMetadata.fromPartial(e)) || [];
    return message;
  },
};

function createBaseResponseMessage(): ResponseMessage {
  return {
    responseToUuid: "",
    response: 0,
    reasonText: undefined,
    messageMetadata: [],
    messageContent: [],
    reconnectToken: undefined,
  };
}

export const ResponseMessage: MessageFns<ResponseMessage> = {
  encode(message: ResponseMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.responseToUuid !== "") {
      writer.uint32(10).string(message.responseToUuid);
    }
    if (message.response !== 0) {
      writer.uint32(16).int32(message.response);
    }
    if (message.reasonText !== undefined) {
      writer.uint32(26).string(message.reasonText);
    }
    for (const v of message.messageMetadata) {
      MessageMetadata.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.messageContent) {
      MessageContent.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.reconnectToken !== undefined) {
      writer.uint32(50).string(message.reconnectToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResponseMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResponseMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.responseToUuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.response = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reasonText = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.messageMetadata.push(MessageMetadata.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.messageContent.push(MessageContent.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reconnectToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResponseMessage {
    return {
      responseToUuid: isSet(object.responseToUuid) ? globalThis.String(object.responseToUuid) : "",
      response: isSet(object.response) ? responseEnumFromJSON(object.response) : 0,
      reasonText: isSet(object.reasonText) ? globalThis.String(object.reasonText) : undefined,
      messageMetadata: globalThis.Array.isArray(object?.messageMetadata)
        ? object.messageMetadata.map((e: any) => MessageMetadata.fromJSON(e))
        : [],
      messageContent: globalThis.Array.isArray(object?.messageContent)
        ? object.messageContent.map((e: any) => MessageContent.fromJSON(e))
        : [],
      reconnectToken: isSet(object.reconnectToken) ? globalThis.String(object.reconnectToken) : undefined,
    };
  },

  toJSON(message: ResponseMessage): unknown {
    const obj: any = {};
    if (message.responseToUuid !== "") {
      obj.responseToUuid = message.responseToUuid;
    }
    if (message.response !== 0) {
      obj.response = responseEnumToJSON(message.response);
    }
    if (message.reasonText !== undefined) {
      obj.reasonText = message.reasonText;
    }
    if (message.messageMetadata?.length) {
      obj.messageMetadata = message.messageMetadata.map((e) => MessageMetadata.toJSON(e));
    }
    if (message.messageContent?.length) {
      obj.messageContent = message.messageContent.map((e) => MessageContent.toJSON(e));
    }
    if (message.reconnectToken !== undefined) {
      obj.reconnectToken = message.reconnectToken;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResponseMessage>, I>>(base?: I): ResponseMessage {
    return ResponseMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResponseMessage>, I>>(object: I): ResponseMessage {
    const message = createBaseResponseMessage();
    message.responseToUuid = object.responseToUuid ?? "";
    message.response = object.response ?? 0;
    message.reasonText = object.reasonText ?? undefined;
    message.messageMetadata = object.messageMetadata?.map((e) => MessageMetadata.fromPartial(e)) || [];
    message.messageContent = object.messageContent?.map((e) => MessageContent.fromPartial(e)) || [];
    message.reconnectToken = object.reconnectToken ?? undefined;
    return message;
  },
};

function createBaseMessageMetadata(): MessageMetadata {
  return { uuid: "", header: undefined };
}

export const MessageMetadata: MessageFns<MessageMetadata> = {
  encode(message: MessageMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.header !== undefined) {
      ApplicationMessageHeader.encode(message.header, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.header = ApplicationMessageHeader.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageMetadata {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      header: isSet(object.header) ? ApplicationMessageHeader.fromJSON(object.header) : undefined,
    };
  },

  toJSON(message: MessageMetadata): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.header !== undefined) {
      obj.header = ApplicationMessageHeader.toJSON(message.header);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageMetadata>, I>>(base?: I): MessageMetadata {
    return MessageMetadata.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageMetadata>, I>>(object: I): MessageMetadata {
    const message = createBaseMessageMetadata();
    message.uuid = object.uuid ?? "";
    message.header = (object.header !== undefined && object.header !== null)
      ? ApplicationMessageHeader.fromPartial(object.header)
      : undefined;
    return message;
  },
};

function createBaseMessageContent(): MessageContent {
  return { uuid: "", msg: undefined };
}

export const MessageContent: MessageFns<MessageContent> = {
  encode(message: MessageContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uuid !== "") {
      writer.uint32(10).string(message.uuid);
    }
    if (message.msg !== undefined) {
      ApplicationMessage.encode(message.msg, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.msg = ApplicationMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageContent {
    return {
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
      msg: isSet(object.msg) ? ApplicationMessage.fromJSON(object.msg) : undefined,
    };
  },

  toJSON(message: MessageContent): unknown {
    const obj: any = {};
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    if (message.msg !== undefined) {
      obj.msg = ApplicationMessage.toJSON(message.msg);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageContent>, I>>(base?: I): MessageContent {
    return MessageContent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageContent>, I>>(object: I): MessageContent {
    const message = createBaseMessageContent();
    message.uuid = object.uuid ?? "";
    message.msg = (object.msg !== undefined && object.msg !== null)
      ? ApplicationMessage.fromPartial(object.msg)
      : undefined;
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
